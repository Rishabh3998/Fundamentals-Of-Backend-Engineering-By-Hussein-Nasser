7. Publish Subscribe (Pub / Sub) (One topic can have many publishers as well as many subscribers/readers)

OVERVIEW:
In a Pub/Sub (Publishâ€“Subscribe) model, a publisher client sends messages to a central broker (or messaging server) without 
needing to know who will receive them. Subscriber clients can then subscribe to specific topics and receive messages delivered
by the broker. Publishers simply publish and move on, while subscribers consume the messages asynchronously.

The Publish-Subscribe (Pub/Sub) model is a messaging pattern where publishers send messages to topics without knowing who will 
receive them, and subscribers receive messages from topics they're interested in. A central message broker decouples publishers 
from subscribers.

KEY COMPONENTS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Publisher - Entity that sends messages to topics
2. Subscriber - Entity that listens to and receives messages from topics
3. Message Broker - Central hub/server that routes messages between publishers and subscribers
4. Topic - Named channel or subject for messages (e.g., "user.signup", "order.created")
5. Message - The actual data/event being transmitted

HOW IT WORKS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Step 1: Publisher publishes a message to a specific topic
Step 2: Message Broker receives the message and stores it
Step 3: Broker identifies all subscribers interested in that topic
Step 4: Broker delivers the message to all active subscribers
Step 5: Subscribers process the message independently and asynchronously

FLOW DIAGRAM:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    Publisher 1
                         â†“
                    Publishes to Topic X
                         â†“
                 Message Broker (Central)
                         â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“                â†“                â†“
    Subscriber 1   Subscriber 2   Subscriber 3
    (Receives)     (Receives)     (Receives)

REAL-WORLD EXAMPLE: E-COMMERCE ORDER SYSTEM
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Scenario: Customer places an order on Amazon

Publisher: Order Service
Topic: "order.created"

Subscribers:
  â€¢ Email Service â†’ Sends order confirmation to customer
  â€¢ Inventory Service â†’ Updates stock/decreases quantity
  â€¢ Analytics Service â†’ Logs order metrics and insights
  â€¢ Notification Service â†’ Sends SMS/Push notification
  â€¢ Billing Service â†’ Processes payment and invoice
  â€¢ Shipping Service â†’ Generates shipping label

When an order is placed:

1. Order Service publishes: {"event": "order.created", "orderId": "12345", "userId": "user001", "amount": "$99.99"}

2. Message Broker routes this message to ALL subscribers interested in "order.created"

3. All subscribers process independently:
   â€¢ Email Service: Sends confirmation email immediately
   â€¢ Inventory Service: Updates stock in parallel
   â€¢ Analytics Service: Logs event for dashboards
   â€¢ Notification Service: Sends SMS alert
   â€¢ Billing Service: Processes payment
   â€¢ Shipping Service: Prepares shipment

Key Benefit: The Order Service doesn't wait for any subscriber to complete. It just publishes and continues!

ADVANTAGES OF PUB/SUB:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ“ DECOUPLING - Publishers and subscribers don't need to know about each other
âœ“ SCALABILITY - Can add/remove subscribers without affecting publishers
âœ“ ASYNCHRONOUS - Non-blocking communication; subscribers process at their own pace
âœ“ FLEXIBILITY - Multiple subscribers can consume same message
âœ“ RELIABILITY - Messages can be persisted and retried on failure
âœ“ FAULT TOLERANCE - If a subscriber is down, publisher isn't affected

DISADVANTAGES OF PUB/SUB:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ— COMPLEXITY - Need message broker infrastructure
âœ— EVENTUAL CONSISTENCY - Data consistency delays as processing is async
âœ— DEBUGGING - Harder to trace messages through multiple subscribers
âœ— ORDERING - May lose message order in high-throughput scenarios
âœ— LATENCY - Not suitable for real-time RPC-style communication

POPULAR PUB/SUB TECHNOLOGIES:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ RabbitMQ - Traditional message broker with routing
â€¢ Apache Kafka - High-throughput event streaming platform
â€¢ Redis Pub/Sub - Lightweight, in-memory pub/sub
â€¢ AWS SNS/SQS - Cloud-based messaging service
â€¢ Google Cloud Pub/Sub - Managed service
â€¢ Azure Service Bus - Microsoft's messaging platform
â€¢ Apache ActiveMQ - Java-based message broker

PUB/SUB vs OTHER PATTERNS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Pub/Sub vs Request-Response (REST API):
  â†’ Pub/Sub is asynchronous; REST is synchronous
  â†’ Pub/Sub decouples services; REST creates tight coupling
  â†’ Pub/Sub better for events; REST better for immediate requests

Pub/Sub vs Point-to-Point (Queues):
  â†’ Pub/Sub: ONE message goes to MULTIPLE subscribers (one-to-many)
  â†’ Queue: ONE message goes to ONE consumer (one-to-one)
  â†’ Pub/Sub: Subscribers must be present to receive (or use persistent topics)
  â†’ Queue: Messages persisted even if no consumer ready

USE CASES FOR PUB/SUB:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Event Notifications (order created, user signed up)
2. Microservices Communication (service A triggers work in services B, C, D)
3. Real-time Analytics (stream data to analytics engines)
4. Cache Invalidation (notify all services when data changes)
5. Audit Logging (all events logged centrally)
6. IoT Data Processing (sensors publish data to multiple analyzers)
7. Social Media Notifications (new post notifies all followers)
8. Stock Price Updates (price changes broadcast to multiple traders)


## Request / Response pros and cons

- Pros:
  - Elegant and Simple
  - Scalable

- Cons:
  - Bad for multiple receivers
  - High Coupling
  - Client and Server have to be running
  - Chaining, Circuit breaker

## Pub/Sub in Action: VIDEO PROCESSING PIPELINE
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SCENARIO: User uploads a video (like YouTube)

Step 1: USER UPLOADS VIDEO
â””â”€â†’ Upload Service receives the video
    â””â”€â†’ Publishes event: "raw_video_uploaded"
        Message: {videoId: "xyz123", filename: "my_video.mp4", size: "500MB"}

Step 2: MESSAGE REACHES PUBSUB BROKER
â””â”€â†’ Broker receives the "raw_video_uploaded" event

Step 3: MULTIPLE SERVICES SUBSCRIBE & PROCESS IN PARALLEL
â”œâ”€â†’ Compress Service (listens to "raw_video_uploaded")
â”‚   â””â”€â†’ Compresses the video â†’ Publishes "video_compressed"
â”‚
â”œâ”€â†’ Format Service (listens to "video_compressed")
â”‚   â””â”€â†’ Creates 480p, 1080p, 4K versions â†’ Publishes "video_formatted"
â”‚
â””â”€â†’ Notification Service (listens to "video_formatted")
    â””â”€â†’ Notifies user: "Your video is ready!"

WORKFLOW TABLE:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Step | Event Published       | Service          | Output                  | Next Event
â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1  | raw_video_uploaded   | Upload Service   | Video file (500MB)      | -
  2  | raw_video_uploaded   | Compress Service | Compressed (50MB)       | video_compressed
  3  | video_compressed     | Format Service   | 480p/1080p/4K files     | video_formatted
  4  | video_formatted      | Notify Service   | User notification       | -

MESSAGE FLOW DIAGRAM:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

                         User Uploads Video
                              â†“
                      â”Œâ”€ Upload Service â”€â”
                      â”‚                   â”‚
                      â””â”€â†’ Publishes: "raw_video_uploaded"
                              â†“
                      Message Broker/Queue
                              â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â†“                   â†“
            Compress Service    Format Service    Notification Service
            (waiting)           (waiting)          (waiting)
                    â†“                   â†“                    â†“
            Receives event     Receives event    Receives event
            "raw_video"        "video_compressed" "video_formatted"
                    â†“                   â†“                    â†“
            Compresses MP4    Creates resolutions Sends SMS/Email/Push
                    â†“                   â†“                    â†“
            Publishes:        Publishes:         User Notified!
            "video_compressed" "video_formatted"


KEY BENEFITS IN THIS EXAMPLE:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. ASYNCHRONOUS PROCESSING
   â””â”€ User doesn't wait for compression/formatting to complete
      Upload completes instantly, processing happens in background

2. INDEPENDENT SCALING
   â””â”€ If many videos need compression â†’ Add more Compress Service instances
   â””â”€ If many videos need formatting â†’ Add more Format Service instances
   â””â”€ Services scale independently without affecting each other

3. LOOSE COUPLING
   â””â”€ Upload Service doesn't call Compress Service directly
   â””â”€ Compress Service doesn't call Format Service directly
   â””â”€ They communicate only through events/messages

4. FAULT TOLERANCE
   â””â”€ If Compress Service crashes, Upload Service still works
   â””â”€ Message stays in queue â†’ Compress Service recovers and processes later
   â””â”€ No cascading failures

5. EXTENSIBILITY
   â””â”€ Want to add AI Thumbnail Generation?
   â””â”€ Just subscribe AI Service to "video_formatted" event
   â””â”€ No changes needed in existing services!

6. PARALLEL PROCESSING
   â””â”€ All formats (480p, 1080p, 4K) can be generated in parallel
   â””â”€ Much faster than sequential processing


COMPARISON: WITH vs WITHOUT PUB/SUB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âŒ WITHOUT PUB/SUB (Direct Coupling):
   Upload Service â†’ calls â†’ Compress Service â†’ calls â†’ Format Service â†’ calls â†’ Notify Service
   Problems:
   â€¢ User waits for entire pipeline (slow)
   â€¢ If any service is down, entire pipeline breaks
   â€¢ Tightly coupled, hard to modify
   â€¢ Can't scale services independently

âœ… WITH PUB/SUB (Event-Driven):
   Upload Service â†’ publishes event â†’ Message Broker
   â”œâ”€ Compress Service picks it up â†’ publishes new event
   â”œâ”€ Format Service picks it up â†’ publishes new event
   â””â”€ Notify Service picks it up â†’ completes
   
   Benefits:
   â€¢ User upload completes instantly
   â€¢ Each service can fail independently
   â€¢ Loosely coupled, easy to modify
   â€¢ Each service scales independently


REAL-WORLD USERS OF THIS PATTERN:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¹ YouTube      â†’ Video processing pipeline
ğŸ¬ Netflix      â†’ Content encoding & streaming
ğŸš— Uber         â†’ Ride requests & notifications
ğŸ“¦ Amazon       â†’ Order processing & tracking
ğŸ’³ Stripe       â†’ Payment workflows
ğŸ“± WhatsApp     â†’ Message delivery
ğŸ›’ Shopify      â†’ Order fulfillment

TECHNOLOGIES USED:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Apache Kafka           (High-throughput event streaming)
â€¢ RabbitMQ             (Reliable message broker)
â€¢ Google Cloud Pub/Sub  (Managed cloud service)
â€¢ AWS SNS + SQS        (Amazon's messaging services)
â€¢ Redis Pub/Sub        (Lightweight, in-memory)
â€¢ Apache ActiveMQ      (Java-based broker)


QUICK REVISION NOTES:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“Œ What is Pub/Sub?
   Producer publishes messages â†’ Consumers subscribe to event(s)
   Enables async communication
   Services don't know about each other (loose coupling)

ğŸ“Œ Key Features:
   âœ“ Asynchronous messaging
   âœ“ Loose coupling between services
   âœ“ Improves scalability
   âœ“ Increases reliability & fault tolerance
   âœ“ Enables parallel processing

ğŸ“Œ Best For:
   â€¢ Multi-step workflows (video processing, order handling)
   â€¢ Payment processing pipelines
   â€¢ Sending notifications
   â€¢ Event tracking & analytics
   â€¢ Real-time data processing

ğŸ“Œ Not Suitable For:
   â€¢ Real-time synchronous requests (use REST APIs)
   â€¢ Simple one-off queries
   â€¢ Immediate response requirements


## Pub / Sub model pros and cons:

- Pros:
  - Scaler with multiple receivers
  - Great for microservices
  - Loose coupling
  - Works even while clients not running

- Cons:
  - Message delivery issues 
  - Complexity
  - Network Saturation
